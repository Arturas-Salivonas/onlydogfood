# Algorithm v2.2.0 Implementation Progress

## Status: CORE COMPLETE ‚úÖ
**Started:** January 10, 2026
**Core Implementation Completed:** January 10, 2026
**Algorithm Version:** 2.2.0

---

## ‚úÖ COMPLETED (Core Features)

### 1. Config Updates (`scoring/config.ts`)
- ‚úÖ Added `ALGORITHM_VERSION = '2.2.0'`
- ‚úÖ Added `FEATURE_FLAGS` for gradual rollout
- ‚úÖ Added `MOISTURE_DEFAULTS` by category
- ‚úÖ Added `ASH_DEFAULTS` by category
- ‚úÖ Added `DM_OPTIMAL_RANGES` for dry matter scoring
- ‚úÖ Added `SPLIT_INGREDIENT_GROUPS` (legumes, corn, rice, potato)
- ‚úÖ Added `SPLIT_INGREDIENT_PENALTIES`
- ‚úÖ Added `RED_FLAG_TIERS` with 4-tier system

### 2. Type Definitions (`types/index.ts`)
- ‚úÖ Added `DryMatterMetrics` interface
- ‚úÖ Added `NutritionMeta` interface
- ‚úÖ Added `EnergyMetrics` interface
- ‚úÖ Added `SplitIngredientGroup` interface
- ‚úÖ Added `SplitIngredientPenalty` interface
- ‚úÖ Added `IngredientMatch` interface (enhanced with position)
- ‚úÖ Added `IngredientAnalysis` interface
- ‚úÖ Added `RedFlagDetection` interface
- ‚úÖ Added `ConfidenceBreakdown` interface
- ‚úÖ Added `ScoringResult` interface (complete v2.2 output)

### 3. Calculator Helper Functions (`scoring/calculator.ts`)
- ‚úÖ Added `computeDryMatterMacros()` function
- ‚úÖ Added `computeCarbsInternal()` helper
- ‚úÖ Added `computeCarbsWithDefaults()` function
- ‚úÖ Added `computeAtwaterEnergy()` function

### 4. Nutrition Scoring with DM Normalization (`scoring/calculator.ts`)
- ‚úÖ Updated `calculateNutritionScore()` signature to accept `dmMetrics`
- ‚úÖ Integrated dry matter basis scoring when feature flag enabled
- ‚úÖ Uses DM optimal ranges: Protein 24-38%, Fat 12-20%, Carbs <30%, Fiber 2-8%
- ‚úÖ Falls back to as-fed basis when flag disabled
- ‚úÖ Returns `nutritionMeta` with transparency tracking

### 5. Value Scoring with Energy-Based Pricing (`scoring/calculator.ts`)
- ‚úÖ Updated `calculateValueScore()` to accept energy metrics and category avg price per 1000kcal
- ‚úÖ Prefers price per 1000kcal when available and feature flag enabled
- ‚úÖ Falls back to price per kg for backward compatibility
- ‚úÖ Rewrote Ingredient-Adjusted Value with smooth weighted formula (55% quality + 45% value)
- ‚úÖ Preserves junk food penalty for cheap + poor quality combinations

### 6. Position Weighting (`scoring/ingredient-matcher.ts`)
- ‚úÖ Added `escapeRegExp()` helper
- ‚úÖ Added `normalizeIngredient()` enhanced for v2.2
- ‚úÖ Added `tokenizeIngredients()` function (splits by commas/semicolons)
- ‚úÖ Added `getPositionMultiplier()` function (1.0 for top 5, 0.6 for 6-10, 0.3 for 11+)
- ‚úÖ Updated `analyzeIngredients()` to use tokens and position weighting
- ‚úÖ Updated `IngredientMatch` to include `positionIndex`, `positionMultiplier`, `weightedPoints`

### 7. Split Ingredient Detection (`scoring/ingredient-matcher.ts`)
- ‚úÖ Added `detectSplitIngredients()` function
- ‚úÖ Checks top 10 ingredients against SPLIT_INGREDIENT_GROUPS
- ‚úÖ Applies penalties: -1.5 for 2 occurrences, -3.0 for 3+
- ‚úÖ Integrated into `calculateIngredientBonusPoints()`
- ‚úÖ Returns detailed breakdown of triggered groups

### 8. Tiered Red Flag System (`scoring/calculator.ts`)
- ‚úÖ Rewrote `checkRedFlagOverride()` with 4-tier detection
  - Tier 1: Ethoxyquin ‚Üí 2 stars max
  - Tier 2: Artificial colors OR colors + sweeteners ‚Üí 3 stars max
  - Tier 3: Unnamed digest in top 5 ‚Üí 3 stars max
  - Tier 4: 3+ controversial additives ‚Üí 4 stars max
- ‚úÖ Returns array of `RedFlagDetection` with detailed info
- ‚úÖ Applies lowest (most strict) cap when multiple flags detected
- ‚úÖ Updated `calculateOverallScore()` to use new structure

### 9. Overall Score Integration (`scoring/calculator.ts`)
- ‚úÖ Updated `calculateOverallScore()` to orchestrate all v2.2 features
- ‚úÖ Computes DM metrics when feature flag enabled
- ‚úÖ Computes energy metrics when feature flag enabled
- ‚úÖ Passes metrics to component scorers
- ‚úÖ Returns complete v2.2 output with `algorithmVersion`, `dmMetrics`, `nutritionMeta`, `energyMetrics`

---

## üìã OPTIONAL ENHANCEMENTS

### 10. Enhanced Confidence Scoring (v2.2 6-component system)
**Status:** NOT IMPLEMENTED (Current v2.1 confidence scoring still functional)
**Priority:** LOW - Can be added later

The v2.1 confidence scoring is still in place and working. The v2.2 enhancement would add:
- Ingredient Disclosure (25 pts)
- Nutrition Completeness (25 pts) - enhanced with DM awareness
- Energy Transparency (15 pts) - explicit vs Atwater estimated
- Carbs Transparency (10 pts) - provided vs estimated
- Sourcing Transparency (15 pts) - named vs unnamed sources
- Manufacturing Info (10 pts) - country, website

### 11. Test Harness
**Status:** NOT IMPLEMENTED
**Priority:** MEDIUM - Recommended before production deployment

Would create `scripts/test-v2.2-algorithm.ts` with:
- 3+ test products (premium dry, budget, wet food)
- v2.1 vs v2.2 comparison
- Validation of DM normalization correctness
- Validation of energy-based pricing changes
- Validation of position weighting effects
- Validation of split detection
- Validation of tiered red flags

---

## üéØ DEPLOYMENT CHECKLIST

### Pre-Deployment
- ‚úÖ All core v2.2 features implemented
- ‚úÖ TypeScript compiles without errors
- ‚ö†Ô∏è Test harness not yet created (RECOMMENDED)
- ‚ö†Ô∏è No live product testing yet

### Feature Flags Strategy
All flags currently in `scoring/config.ts`:
```typescript
FEATURE_FLAGS = {
  USE_DM_NUTRITION: false,           // Start disabled
  USE_KCAL_VALUE: false,              // Start disabled
  USE_POSITION_WEIGHTING: false,      // Start disabled
  USE_SPLIT_INGREDIENT_PENALTY: false // Start disabled
}
```

**Recommended Rollout:**
1. Deploy with all flags OFF ‚Üí No changes visible (v2.1 behavior)
2. Enable `USE_DM_NUTRITION` ‚Üí Monitor for 2-3 days
3. Enable `USE_KCAL_VALUE` ‚Üí Monitor wet/raw food scores
4. Enable `USE_POSITION_WEIGHTING` ‚Üí Check ingredient scoring changes
5. Enable `USE_SPLIT_INGREDIENT_PENALTY` ‚Üí Verify gaming prevention works
6. Full v2.2.0 when stable

### Database Updates Needed
When deploying, you may need to:
1. Add `categoryAveragePricePer1000kcal` column or compute on-the-fly
2. Potentially recalculate all product scores (run migration script)
3. Update any cached aggregates (category averages, top products, etc.)

---

## üìä IMPLEMENTATION STATISTICS

**Lines of Code Changed:**
- `scoring/config.ts`: +150 lines (new constants)
- `types/index.ts`: +120 lines (new interfaces)
- `scoring/calculator.ts`: +450 lines (helpers + updates)
- `scoring/ingredient-matcher.ts`: +180 lines (tokenization + weighting)
- **Total: ~900 lines of new/modified code**

**Files Modified:** 4
**New Functions:** 12
**New Interfaces:** 10
**Feature Flags:** 4

---

## üêõ KNOWN LIMITATIONS

1. **Category Average Price per 1000kcal**: Not yet computed or stored in database
   - Workaround: Can compute on-the-fly or pass `undefined` (falls back to per kg)

2. **Confidence Scoring**: Still using v2.1 system
   - Impact: Confidence scores won't reflect DM/energy metadata quality
   - Workaround: Current system still functional

3. **No Regression Tests**: Test harness not created yet
   - Impact: Can't validate scoring changes at scale
   - Recommendation: Create before production deployment

4. **No Migration Script**: No automated recalculation of existing products
   - Impact: Old scores remain until products are rescored
   - Recommendation: Create `scripts/recalculate-v2.2-scores.ts`

---

## üéì TECHNICAL NOTES

### Dry Matter Normalization
Converts all macros to dry matter basis for fair comparison:
```
proteinDM = (protein_as_fed / dmPercent) * 100
where dmPercent = 100 - moisture
```

Category defaults used when moisture/ash missing:
- Dry food: 10% moisture, 8% ash
- Wet food: 78% moisture, 2.5% ash
- Raw food: 70% moisture, 3% ash

### Energy-Based Pricing
Modified Atwater formula for metabolizable energy:
```
kcal/100g = 3.5*protein + 8.5*fat + 3.5*carbs
price_per_1000kcal = (price_per_kg / kcal_per_kg) * 1000
```

### Position Weighting
Applies multipliers based on ingredient position:
- Position 1-5: 1.0√ó (full points)
- Position 6-10: 0.6√ó (moderate penalty)
- Position 11+: 0.3√ó ("pixie dust" penalty)

### Split Detection
Checks top 10 for multiple forms of:
- Legumes (peas, lentils, chickpeas, beans)
- Corn (corn, maize, cornmeal, corn gluten)
- Rice (rice, rice flour, brewers rice)
- Potato (potato, potato starch, potato protein)

Penalties: -1.5 for 2, -3.0 for 3+

---

**Last Updated:** January 10, 2026
**Implementation Progress:** 90% Complete (9 of 10 core features)
**Production Ready:** With feature flags OFF - YES | With flags ON - Needs testing

---

## üöß IN PROGRESS

### 4. Nutrition Scoring Update
**Status:** Ready to implement
**Location:** `scoring/calculator.ts` - `calculateNutritionScore()`

**Required Changes:**
```typescript
// Modify function signature to:
export function calculateNutritionScore(
  product: Product,
  dmMetrics?: DryMatterMetrics
): {
  score: number;
  details: Record<string, number>;
  nutritionMeta: NutritionMeta;
}

// Logic updates:
1. Check if FEATURE_FLAGS.USE_DM_NUTRITION is true
2. If true and dmMetrics provided:
   - Use proteinDM with DM_OPTIMAL_RANGES
   - Use fatDM with DM optimal 12-20%
   - Use carbsDM with DM optimal <30%
   - Use fiberDM with DM optimal 2-8%
3. If false or no dmMetrics:
   - Fall back to existing v2.1 as-fed logic
4. Return nutritionMeta showing what was used
```

### 5. Value Scoring Update
**Status:** Ready to implement
**Location:** `scoring/calculator.ts` - `calculateValueScore()`

**Required Changes:**
```typescript
// Modify function signature to:
export function calculateValueScore(
  product: Product,
  categoryAveragePricePerKg: number,
  categoryAveragePricePer1000kcal: number | undefined,
  ingredientQuality: number,
  energyMetrics?: EnergyMetrics
): {
  score: number;
  details: Record<string, number>;
}

// Logic updates:
1. Check if FEATURE_FLAGS.USE_KCAL_VALUE is true
2. If true and energyMetrics with pricePer1000kcal:
   - Use kcal-based comparison for Price Competitiveness
3. Else fall back to price/kg
4. Rewrite Ingredient-Adjusted Value with smooth formula:
   - qualityRatio = ingredientScore / 45
   - valueRatio = avgPrice / productPrice
   - Normalize valueRatio: 0.7->1.3 maps to 0->1
   - points = 7 * (0.55*quality + 0.45*normalize(value))
   - Preserve junk food penalty
```

---

## üìã TODO (Remaining Tasks)

### 6. Ingredient Matcher Tokenization
**Priority:** HIGH
**Location:** `scoring/ingredient-matcher.ts`

**Tasks:**
- [ ] Add `escapeRegExp()` helper function
- [ ] Add `normalizeToken()` function
- [ ] Add `tokenizeIngredients()` function
- [ ] Add `getPositionMultiplier()` function
- [ ] Update `IngredientMatch` interface (already done in types)
- [ ] Update `analyzeIngredients()` to use tokens
- [ ] Update `calculateIngredientBonusPoints()` for weighted scoring
- [ ] Add feature flag check for `USE_POSITION_WEIGHTING`

**Code Template:**
```typescript
function escapeRegExp(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function normalizeToken(token: string): string {
  return token
    .toLowerCase()
    .replace(/\([^)]*\)/g, '')
    .replace(/[.,;!?()[\]{}]/g, '')
    .replace(/\s+/g, ' ')
    .trim();
}

interface TokenInfo {
  token: string;
  normalizedToken: string;
  positionIndex: number;
}

function tokenizeIngredients(ingredientText: string): TokenInfo[] {
  // Split by commas and semicolons
  const tokens = ingredientText
    .split(/[,;]/)
    .map((t, index) => ({
      token: t.trim(),
      normalizedToken: normalizeToken(t.trim()),
      positionIndex: index,
    }))
    .filter(t => t.normalizedToken.length > 0);

  return tokens;
}

function getPositionMultiplier(positionIndex: number): number {
  if (positionIndex <= 4) return 1.0;
  if (positionIndex <= 9) return 0.6;
  return 0.3;
}
```

### 7. Split Ingredient Detection
**Priority:** HIGH
**Location:** `scoring/ingredient-matcher.ts`

**Tasks:**
- [ ] Add `detectSplitIngredients()` function
- [ ] Integrate into `calculateIngredientBonusPoints()`
- [ ] Add feature flag check for `USE_SPLIT_INGREDIENT_PENALTY`

**Code Template:**
```typescript
import { SPLIT_INGREDIENT_GROUPS, SPLIT_INGREDIENT_PENALTIES } from './config';

function detectSplitIngredients(tokens: TokenInfo[]): SplitIngredientPenalty {
  const top10Tokens = tokens.slice(0, 10);
  const groupsTriggered: SplitIngredientGroup[] = [];
  let totalPenalty = 0;

  for (const [groupName, ingredients] of Object.entries(SPLIT_INGREDIENT_GROUPS)) {
    const matchedTokens: string[] = [];

    for (const token of top10Tokens) {
      for (const ingredient of ingredients) {
        const regex = new RegExp(`\\b${escapeRegExp(ingredient)}\\b`, 'i');
        if (regex.test(token.normalizedToken)) {
          matchedTokens.push(token.token);
          break; // Count each token once per group
        }
      }
    }

    const count = matchedTokens.length;
    if (count >= 2) {
      groupsTriggered.push({
        groupName,
        countInTop10: count,
        tokensMatched: matchedTokens,
      });

      const penalty = count >= 3
        ? SPLIT_INGREDIENT_PENALTIES.THREE_PLUS_IN_TOP_10
        : SPLIT_INGREDIENT_PENALTIES.TWO_IN_TOP_10;

      totalPenalty += penalty;
    }
  }

  return {
    penalty: totalPenalty,
    groupsTriggered,
  };
}
```

### 8. Tiered Red Flag System
**Priority:** HIGH
**Location:** `scoring/calculator.ts`

**Tasks:**
- [ ] Rewrite `checkRedFlagOverride()` function
- [ ] Check all 4 tiers + combo rule
- [ ] Return detailed `RedFlagDetection[]`
- [ ] Apply lowest cap when multiple flags

**Code Template:**
```typescript
import { RED_FLAG_TIERS } from './config';
import { RedFlagDetection } from '@/types';

function checkRedFlagOverride(
  product: Product,
  ingredientText: string,
  top5Ingredients: string[]
): {
  redFlagsDetected: RedFlagDetection[];
  finalStarCapApplied: number | null;
} {
  const redFlagsDetected: RedFlagDetection[] = [];
  const ingredientsLower = ingredientText.toLowerCase();

  // Tier 1: Ethoxyquin
  const tier1 = RED_FLAG_TIERS.TIER_1_ETHOXYQUIN;
  for (const ingredient of tier1.ingredients) {
    if (ingredientsLower.includes(ingredient)) {
      redFlagsDetected.push({
        ruleId: 'TIER_1_ETHOXYQUIN',
        tier: tier1.tier,
        capStars: tier1.maxStars,
        reason: tier1.description,
        matchedTokens: [ingredient],
      });
      break;
    }
  }

  // Tier 2: Artificial Colors
  const tier2Colors = RED_FLAG_TIERS.TIER_2_ARTIFICIAL_COLORS;
  const matchedColors = tier2Colors.ingredients.filter(ing =>
    ingredientsLower.includes(ing)
  );
  if (matchedColors.length > 0) {
    redFlagsDetected.push({
      ruleId: 'TIER_2_ARTIFICIAL_COLORS',
      tier: tier2Colors.tier,
      capStars: tier2Colors.maxStars,
      reason: tier2Colors.description,
      matchedTokens: matchedColors,
    });
  }

  // Tier 2: Colors + Sweeteners combo
  const tier2Combo = RED_FLAG_TIERS.TIER_2_COLORS_SWEETENERS;
  const hasColors = tier2Combo.colorIngredients.some(ing =>
    ingredientsLower.includes(ing)
  );
  const hasSweeteners = tier2Combo.sweetenerIngredients.some(ing =>
    ingredientsLower.includes(ing)
  );
  if (hasColors && hasSweeteners) {
    redFlagsDetected.push({
      ruleId: 'TIER_2_COLORS_SWEETENERS',
      tier: tier2Combo.tier,
      capStars: tier2Combo.maxStars,
      reason: tier2Combo.description,
      matchedTokens: ['colors + sweeteners'],
    });
  }

  // Tier 3: Unnamed digest in top 5
  const tier3 = RED_FLAG_TIERS.TIER_3_UNNAMED_DIGEST;
  const top5Lower = top5Ingredients.map(i => i.toLowerCase()).join(' ');
  const matchedDigest = tier3.ingredientsInTop5.filter(ing =>
    top5Lower.includes(ing)
  );
  if (matchedDigest.length > 0) {
    redFlagsDetected.push({
      ruleId: 'TIER_3_UNNAMED_DIGEST',
      tier: tier3.tier,
      capStars: tier3.maxStars,
      reason: tier3.description,
      matchedTokens: matchedDigest,
    });
  }

  // Tier 4: 3+ controversial additives
  const tier4 = RED_FLAG_TIERS.TIER_4_CONTROVERSIAL_ADDITIVES;
  const matchedControversial = tier4.ingredients.filter(ing =>
    ingredientsLower.includes(ing)
  );
  if (matchedControversial.length >= tier4.threshold) {
    redFlagsDetected.push({
      ruleId: 'TIER_4_CONTROVERSIAL_ADDITIVES',
      tier: tier4.tier,
      capStars: tier4.maxStars,
      reason: tier4.description,
      matchedTokens: matchedControversial,
    });
  }

  // Apply lowest cap (most strict)
  const finalStarCapApplied = redFlagsDetected.length > 0
    ? Math.min(...redFlagsDetected.map(f => f.capStars))
    : null;

  return { redFlagsDetected, finalStarCapApplied };
}
```

### 9. Enhanced Confidence Scoring
**Priority:** MEDIUM
**Location:** `scoring/calculator.ts`

**Tasks:**
- [ ] Rewrite `calculateConfidenceScore()` with 6 components
- [ ] Add detailed breakdown
- [ ] Return `ConfidenceBreakdown` interface

**Code Template:**
```typescript
function calculateConfidenceScore(
  product: Product,
  nutritionMeta: NutritionMeta,
  energyMetrics: EnergyMetrics
): {
  score: number;
  level: 'High' | 'Medium' | 'Low';
  breakdown: ConfidenceBreakdown;
} {
  const details: string[] = [];
  const breakdown: Partial<ConfidenceBreakdown> = {};
  let totalScore = 0;

  // 1. Ingredient Disclosure (25 pts)
  const ingredientsText = product.ingredients_raw || '';
  const percentageMatches = ingredientsText.match(/\d+%/g);
  const percentCount = percentageMatches ? percentageMatches.length : 0;

  if (percentCount >= 3) {
    breakdown.ingredientDisclosure = 25;
    details.push('Full ingredient disclosure (3+ percentages)');
  } else if (percentCount >= 1) {
    breakdown.ingredientDisclosure = 12;
    details.push('Partial ingredient disclosure');
  } else {
    breakdown.ingredientDisclosure = 0;
    details.push('No ingredient percentages disclosed');
  }
  totalScore += breakdown.ingredientDisclosure;

  // 2. Nutrition Completeness (25 pts)
  const nutritionItems = [
    { name: 'protein', value: product.protein_percent, estimated: false },
    { name: 'fat', value: product.fat_percent, estimated: false },
    { name: 'fiber', value: product.fiber_percent, estimated: false },
    { name: 'moisture', value: product.moisture_percent, estimated: nutritionMeta.moistureEstimated },
    { name: 'ash', value: product.ash_percent, estimated: nutritionMeta.ashEstimated },
  ];

  let nutritionPoints = 0;
  nutritionItems.forEach(item => {
    if (item.value !== null && item.value !== undefined) {
      if (item.estimated) {
        nutritionPoints += 2.5; // Half credit for estimated
      } else {
        nutritionPoints += 5; // Full credit
      }
    }
  });
  breakdown.nutritionCompleteness = nutritionPoints;
  totalScore += nutritionPoints;

  // 3. Energy Transparency (15 pts)
  if (product.calories_per_100g) {
    breakdown.energyTransparency = 15;
    details.push('Calories explicitly stated');
  } else if (energyMetrics.usedAtwaterEstimate && energyMetrics.kcalPer100g) {
    breakdown.energyTransparency = 7;
    details.push('Calories estimated via Atwater');
  } else {
    breakdown.energyTransparency = 0;
    details.push('No calorie information');
  }
  totalScore += breakdown.energyTransparency;

  // 4. Carbs Transparency (10 pts)
  if (nutritionMeta.carbsProvided) {
    breakdown.carbsTransparency = 10;
    details.push('Carbs explicitly provided');
  } else if (!nutritionMeta.ashEstimated && !nutritionMeta.moistureEstimated) {
    breakdown.carbsTransparency = 6;
    details.push('Carbs computed with complete data');
  } else if (nutritionMeta.carbsEstimated) {
    breakdown.carbsTransparency = 2;
    details.push('Carbs estimated with defaults');
  } else {
    breakdown.carbsTransparency = 0;
  }
  totalScore += breakdown.carbsTransparency;

  // 5. Sourcing Transparency (15 pts)
  const ingredientsLower = ingredientsText.toLowerCase();
  const hasNamed = NAMED_MEAT_SOURCES.some(m => ingredientsLower.includes(m));
  const hasUnnamed = UNNAMED_MEAT_SOURCES.some(m => ingredientsLower.includes(m));

  if (hasNamed && !hasUnnamed) {
    breakdown.sourcingTransparency = 15;
    details.push('All named animal sources');
  } else if (hasNamed) {
    breakdown.sourcingTransparency = 8;
    details.push('Mixed named/unnamed sources');
  } else {
    breakdown.sourcingTransparency = 0;
    details.push('Generic/unnamed sources');
  }
  totalScore += breakdown.sourcingTransparency;

  // 6. Manufacturing Info (10 pts)
  const hasOrigin = product.brand?.country_of_origin !== null;
  const hasWebsite = product.brand?.website_url !== null;

  if (hasOrigin && hasWebsite) {
    breakdown.manufacturingInfo = 10;
    details.push('Complete manufacturing info');
  } else if (hasOrigin || hasWebsite) {
    breakdown.manufacturingInfo = 5;
    details.push('Partial manufacturing info');
  } else {
    breakdown.manufacturingInfo = 0;
    details.push('No manufacturing info');
  }
  totalScore += breakdown.manufacturingInfo;

  // Determine level
  const level: 'High' | 'Medium' | 'Low' =
    totalScore >= 80 ? 'High' :
    totalScore >= 50 ? 'Medium' : 'Low';

  return {
    score: Math.round(totalScore),
    level,
    breakdown: breakdown as ConfidenceBreakdown,
  };
}
```

### 10. Update calculateOverallScore()
**Priority:** HIGH
**Location:** `scoring/calculator.ts`

**Tasks:**
- [ ] Update function to compute all new metrics
- [ ] Return complete `ScoringResult` interface
- [ ] Add warnings array for graceful degradation
- [ ] Ensure backward compatibility

### 11. Create Test Harness
**Priority:** MEDIUM
**Location:** `scripts/test-v2.2-algorithm.ts`

**Tasks:**
- [ ] Create test products (premium dry, budget, wet)
- [ ] Run v2.1 vs v2.2 comparison
- [ ] Validate DM normalization
- [ ] Validate energy-based pricing
- [ ] Validate position weighting
- [ ] Validate split detection
- [ ] Validate tiered red flags
- [ ] Generate comparison report

---

## üéØ NEXT STEPS

1. **Complete Nutrition Scoring DM Update** (Task 4)
2. **Complete Value Scoring Energy Update** (Task 5)
3. **Implement Ingredient Tokenization** (Task 6)
4. **Implement Split Detection** (Task 7)
5. **Implement Tiered Red Flags** (Task 8)
6. **Complete Confidence v2.2** (Task 9)
7. **Update calculateOverallScore()** (Task 10)
8. **Create Test Script** (Task 11)
9. **Run Tests & Validate**
10. **Update Documentation**

---

## üìù IMPLEMENTATION NOTES

### Current State
- Foundation is complete (config, types, helper functions)
- Core helpers for DM, carbs, and energy are implemented
- Ready to integrate into scoring functions

### Blockers
None currently - all dependencies are in place

### Testing Strategy
1. Create test products with known characteristics
2. Compare v2.1 vs v2.2 scores
3. Validate each new feature independently
4. Run full regression suite
5. Check performance (target: <100ms per product)

### Rollout Plan
1. Deploy with all feature flags OFF
2. Enable USE_DM_NUTRITION first
3. Monitor for 1-2 days
4. Enable remaining flags one by one
5. Full rollout when stable

---

**Last Updated:** January 10, 2026
**Implementation Progress:** 35% Complete (tasks 1-3 of 11)
